# DNS management system with REST API and DDNS update endpoint

## Summary

teleddns-server is a DNS management with special features:
* it supports orchestrating zones on multiple DNS servers
* it offers REST API for its data model
* there is an admin interface based on starlette-admin
* there is a DDNS update endpoint API

## Functions

### DDNS

`https://server.tld/ddns/update?hostname=dynamichost.domain.tld&myip=1.2.3.4` and an alternative endpoint
`https://server.tld/update?hostname=dynamichost.domain.tld&myip=1.2.3.4`

This update operation supports both IPv4 and IPv6, that ends up updating the relevant A or AAAA records. The old A/AAAA records
are always replaced and there is also a deletion option with empty `myip` parameter that would delete all A and AAAA records for the
hostname.

DDNS request authorization uses either basic auth (with user+password stored in the DB) or a bearer token (also stored in the DB and
asociated with the user, one user can have multiple tokens).
If the user has 2FA or PassKey enabled then the basic auth is not allowed and the bearer token has to be used by the user.

### DNS REST API

There is a DB model that contains:
* User and Groups, there is N:M user-group relation.
* There is a UserLabelAuthorization table and GroupLabelAuthorization table that can add an explicit write right to an user or a group for a specific label in a zone that is not owned by that user. (This replaces the existing AccessRule table.)
* User can have 2FA TOTP or PassKey or it can be linked to SSO (SAML).
* API Bearer Tokens (associated with the user and also containing an optional description for each token).
* DNS Master Server (with URL for backend API, bearer token and a name of master template).
* Zone - associated to one DNS Master server, one user (owner) and group (can be null) that can see and make changes to.
* All relevant DNS RR types (associated to the zone where the RR belongs.

REST API authentication requires to use the bearer tokens.
The REST API allows the authenticated users to access all of these objects based on their privileges. The User, Group and API Bearer Tokens
are accessible only to admin users.
The API Bearer Tokens are accessible to the Users but only their own tokens and the user can create, get and delete them. No updates are allowed and the new tokens are always generated by the server.

The API validates the user input to the point that the user can not create invalid RRs and zones. When the zone is being created the necessary SOA values and NS records
are created using default values. The SOA serial is automatically incremented, unless the API is explicitly commanded not to do so.

### Admin interface

The model is also accessible using the Admin interface (`/admin`). Only admin users can access the admin interface.

### Web interface

DO NOT IMPLEMENT THIS PART!!! Use this just for future planning.

The user have to login to access the web interface. The web interface would show the zones, the users can create new zones and edit and delete the zones that they
own. The user can not create a new zone if the same zone already exists and the user can not see it because he is not authozied for the zone.
The web allows to edit the zone and the RR inside the zone and guids the user to create valid zone (the SOA and NS records are auto-generated) and breaking edits
are not allowed. The SOA serial is automatically incremented on changes.

## Interaction with the backend server

### Backend REST API

The backend Knot DNS daemon that would work as the master server (we can have more) is supplemented with a simple HTTP(S) API that supports the following
commands:

```
- endpoint: "/zonewrite"
  parametes: [ "zonename", ]
  method: POST
  request_body: "zonefile as application/octet-stream or text/plain"
  body: "debug output, to be logged"
- endpoint: "/configwrite"
  parametes: [ ]
  method: POST
  request_body: "config file as application/octet-stream or text/plain"
  body: "debug output, to be logged"
- endpoint: "/zonereload"
  parametes: [ "zonename", ]
  method: GET
  body: "command output, to be logged"
- endpoint: "/zonecheck"
  parametes: [ "zonename", ]
  method: POST
  request_body: "zonefile as application/octet-stream or text/plain"
  body: "command output"
- endpoint: "/configreload"
  parametes: [ ]
  method: GET
  body: "command output, to be logged"
```

The URL base and the bearer token and the name of the master template to use for the server is in the Server model object.

The server expect config file like:
```
zone:
- domain: d.telephant.eu.
  template: t_master
  file: d.telephant.eu.zone
- domain: openaviation.eu.
  template: t_master
  file: openaviation.eu.zone
```

And the zones pushed to the server have to be valid BIND zone files (Knot is used in fact).

### Timing

The teleddns-server supports dynamic timing for pushing the changes made over admin/web/REST API and DDNS API to the backend server. By default the server starts a background task on startup that waits for changes. We remember for each zone and server if there are any any un-synced changes and when was the last sync.

When there is a change from any source the background task wakes up, waits for UPDATE_DELAY=10 (seconds) and then checks what zones or servers need push & reload. Any zones that were updated in the interval (now-UPDATE_MINIMUM_DELAY, now) are skipped - default UPDATE_MINIMUM_DELAY=3*UPDATE_DELAY. Every UPDATE_INTERVAL=600 the background thread wakes and does the same procedure.

Only after the zone is successfully pushed and reloaded on the backend server the dirty flags get cleared and the update time is recorded. The same applies to server config sync.

There is a parameter --disable-backend-loop that prevents this backend loop to start.

## Security, auditing and observability

The software produces an audit log (using Python logging library). The log records includes all changes to any DNS objects and Users, Groups etc., excluding the passwords and tokens. The source (Web, Admin, REST API, DDNS) are recorded along with the source IP of the request.

The push operations to the backend server are also logged with the name and SOA serials for the zones that are being pushed.

The app should also have `/healthcheck` endpoint that would report `OK uptime=<seconds> last_update=<timestamp1> last_push=<timestamp2>`. The last_update is the timestamp of the last update form any source and the last_push is the timestampt for the last successful sync to all backend servers.

If `last_update > WARN_ON_NOUPDATE and uptime > WARN_ON_NOUPDATE` change `OK` to `WARN`. Default `WARN_ON_NOUPDATE=7200`.
If `last_push > WARN_ON_NOPUSH and uptime > WARN_ON_NOPUSH` change `OK` to `WARN`. Default `WARN_ON_NOPUSH=3600`.

Create also Prometheus observability endpoint that would show number of changes per zone, number of zones and number of records in each zone and backend sync time.

## Tech stack

Use the following libraries:

* Python & poetry
* FastAPI
* Pydantic for the API and for config
* SQLModel + SQLAlchemy
* FastAPI-Users
* starlette-admin
* HTMX with Bootstrap
* try to minimize use of JavaScript
* Sqlite for the DB
